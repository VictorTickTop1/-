(*) - да, bool занимает 1 байт (8 бит), так как это минимальная адресуемая ячейка памяти.
  Есть способы запаковать логические переменные в 1 бит, о них поговорим в другом уроке.
(**) - на ESP8266/ESP32 int и unsigned int занимает 4 байта, то есть является аналогами типов long и unsigned long!
(***) - Компилятор также поддерживает 64 битные числа.
  Стандартные Arduino-библиотеки с переменными этого типа не работают, поэтому можно использовать только в своём коде.

Максимальные значения хранятся в константах, которые можно использовать в коде. Иногда это помогает избавиться от лишних вычислений:

-UINT8_MAX - 255
-INT8_MAX - 127
-UINT16_MAX - 65 535
-INT16_MAX - 32 767
-UINT32_MAX- 4 294 967 295
-INT32_MAX - 2 147 483 647
-UINT64_MAX - 18 446 744 073 709 551 615
-INT64_MAX - ‭9 223 372 036 854 775 807

ЛОГИЧЕСКИЙ ТИП
bool - логический, он же булевый (придуман Джорджем Булем) тип данных, принимает значения 0 и 1 или false и true - ложь и правда.
Используется для хранения состояний, например включено/выключено, а также для работы в условных конструкциях.

Также переменная типа bool принимает значение true, если присвоить ей любое отличное от нуля число.
                            bool a = 0;  // false
                            bool b = 1;  // true
                            bool c = 25; // true

СИМВОЛЬНЫЙ ТИП
char - тип данных для хранения символов, символ указывается в одинарных кавычках:  char var = 'a';.
По факту это целочисленный тип данных, а переменная хранит номер (код) символа в таблице ASCII

Из символов можно составлять строки, об этом более подробно поговорим в уроках про символьные строки и String-строки.

Несмотря на то, что в языке Си символ это по сути целое число, значения например '3' и 3 не равны между собой,
потому что символ '3' с точки зрения программы является числом 51. На практике иногда бывает нужно конвертировать символы чисел в соответствующие им целые числа и наоборот
(при работе со строками и буферами вручную), для этого распространены следующие алгоритмы:

Из символа в число - взять младший ниббл (4 бита): symbol & 0xF
Из символа в число - вычесть символ 0: symbol - '0'
Из числа в символ - прибавить символ 0: symbol + '0'

Выше в таблице есть пометка "точность: 6-7 знаков" - это означает, что в этом типе можно хранить числа, размер которых не больше 6-7 цифр,
остальные цифры будут утеряны! Причём целой части отдаётся приоритет.
Вот так это выглядит в числах (в комментарии - реальное число, которое записалось в переменную):

                                                          float v;
                                                          v = 123456.654321;    // 123456.656250
                                                          v = 0.0123456789;     // 0.0123456788
                                                          v = 0.0000123456789;  // 0.0000123456788
                                                          v = 123456789;        // 123456792.0


Как переменную, указав перед типом данных слово const: const тип_данных имя = значение;. Пример: const byte myConst = 10;.
По сути это будет обычная переменная, но её значение нельзя поменять. Особенности:

-Занимает место в оперативной памяти, но может быть оптимизирована (вырезана) компилятором, если используется просто как значение.
-Имеет адрес в памяти, по которому к ней можно обратиться.
-Вычисления с ней не оптимизируются и чаще всего выполняются точно так же, как с обычными переменными.
-Компилятор выдаст ошибку, если имя константы совпадает с именем другой переменной в программе.

При помощи директивы #define, без знака равенства и точки с запятой в конце: #define имя значение. Пример: #define BTN_PIN 10.
Работает так: указанное имя буквально заменяется в тексте программы на указанное значение. Такая дефайн-константа:

-Не занимает места в оперативной памяти, а хранится во Flash памяти как часть кода программы.
-Не имеет адреса в оперативной памяти.
-Вычисления с такими константами оптимизируются и выполняются быстрее, так как это просто цифры.
-Если имя дефайн-константы совпадёт с именем другого "объекта" в программе или даже в библиотеке - работа может быть непредсказуемой: можно получить невнятную ошибку компиляции, либо программа может просто работать некорректно! Дефайн буквально заменяет текст в коде программы, это довольно опасная штука.
!!!!!!!!Во избежание проблем нужно называть дефайн-константы максимально уникальными именами. Можно добавлять к ним префиксы,
например вместо PERIOD сделать MY_PERIOD и так далее.!!!!!!!!!!!!!

Переменные, константы const и другие создаваемые пользователем данные имеют такое важное понятие, как область видимости. Она бывает глобальной и локальной.

                                                            Глобальная
Глобальная переменная:

Объявляется вне функций, например просто в начале программы.
Доступна для чтения и записи в любом месте программы.
Находится в оперативной памяти на всём протяжении работы программы, то есть не теряет своё значение.
При объявлении имеет нулевое значение.
                    byte var;   // глобальная переменная
                    void setup() {
                      var = 50;
                    }
                    void loop() {
                      var = 70;
                    }
                                                              Локальная
Локальная переменная:

Объявляется внутри любого блока кода, заключённого в { фигурные скобки }.
Доступна для чтения и записи только внутри своего блока кода (и во всех вложенных в него).
Находится в оперативной памяти с момента объявления и до закрывающей фигурной скобки, то есть удаляется из памяти и её значение стирается.
При объявлении имеет случайное значение.
Важный момент: если имя локальной переменной совпадает с одной из глобальных, то приоритет обращения отдаётся локальной переменной (в её области определения).

                      byte var; // глобальная переменная
                      void setup() {
                       byte var;  // локальная переменная
                       var = 50;  // меняем локальную var
                      }
                      void loop() {
                       var = 70;  // меняем глобальную var
                      }


Вспомним, как работает обычная локальная переменная: при входе в свой блок кода локальная переменная создаётся заново,
а при выходе - удаляется из памяти и теряет своё значение.Если локальная переменная объявлена как static - 
она будет сохранять своё значение на всём протяжении работы программы, но область видимости останется локальной:
взаимодействовать с переменной можно будет только внутри блока кода, где она создана (и во всех вложенных в него).

                      void setup() {
                      }
                      void loop() {
                       byte varL = 0;
                       varL++;
                        static byte varS = 0;
                        varS++;
                      // здесь varL всегда будет равна 1
                      // а varS - постоянно увеличиваться
                      }
Статические переменные позволяют более красиво организовывать свой код, избавляясь от лишних глобальных переменных.

Преобразование типов
Иногда требуется преобразовать один тип данных в другой: например, функция принимает int, а вы хотите передать ей byte. В большинстве случаев компилятор сам разберётся и преобразует byte в int, но иногда вылетает ошибка в стиле "попытка передать byte туда, где ждут int". В таком случае можно преобразовать тип данных, для этого достаточно указать нужный тип данных в скобках перед преобразуемой переменной (тип_данных)переменная, иногда можно встретить запись тип_данных(переменная). Результат вернёт переменную с новым типом данных, сам же тип данной у переменной не изменится. Например:

                      // переменная типа byte
                      byte val = 10;
                      // передаём какой-то функции, которая ожидает int
                      sendVal( (int)val );
И всё! val будет обрабатываться как int, а не как byte.
